/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function() {

eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n// 도형의 타입을 정의하는 enum\nvar ShapeType;\n(function (ShapeType) {\n    ShapeType[ShapeType[\"Line\"] = 0] = \"Line\";\n    ShapeType[ShapeType[\"Arrow\"] = 1] = \"Arrow\";\n    ShapeType[ShapeType[\"Circle\"] = 2] = \"Circle\";\n    ShapeType[ShapeType[\"Rectangle\"] = 3] = \"Rectangle\";\n    ShapeType[ShapeType[\"Triangle\"] = 4] = \"Triangle\";\n    ShapeType[ShapeType[\"Freehand\"] = 5] = \"Freehand\";\n})(ShapeType || (ShapeType = {}));\n// 선 스타일을 정의하는 enum\nvar LineStyle;\n(function (LineStyle) {\n    LineStyle[LineStyle[\"Solid\"] = 0] = \"Solid\";\n    LineStyle[LineStyle[\"Dashed\"] = 1] = \"Dashed\";\n})(LineStyle || (LineStyle = {}));\n// 모든 도형의 기본이 되는 추상 클래스\nvar Shape = /** @class */ (function () {\n    function Shape(ctx, lineColor, fillColor, lineWidth, lineStyle) {\n        this.ctx = ctx;\n        this.lineColor = lineColor;\n        this.fillColor = fillColor;\n        this.lineWidth = lineWidth;\n        this.lineStyle = lineStyle;\n    }\n    return Shape;\n}());\n// 선 클래스\n// Line 클래스 수정\nvar Line = /** @class */ (function (_super) {\n    __extends(Line, _super);\n    function Line(ctx, startX, startY, endX, endY, lineColor, lineWidth, lineStyle) {\n        var _this = _super.call(this, ctx, lineColor, \"\", lineWidth, lineStyle) || this;\n        _this.startX = startX;\n        _this.startY = startY;\n        _this.endX = endX;\n        _this.endY = endY;\n        return _this;\n    }\n    Line.prototype.draw = function () {\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.startX, this.startY);\n        this.ctx.lineTo(this.endX, this.endY);\n        this.ctx.strokeStyle = this.lineColor;\n        this.ctx.lineWidth = this.lineWidth;\n        if (this.lineStyle === LineStyle.Dashed) {\n            this.ctx.setLineDash([5, 5]);\n        }\n        else {\n            this.ctx.setLineDash([]);\n        }\n        this.ctx.stroke();\n    };\n    Line.prototype.isPointInside = function (x, y) {\n        var threshold = 5; // 픽셀 단위의 임계값\n        var distToLine = Math.abs((this.endY - this.startY) * x -\n            (this.endX - this.startX) * y +\n            this.endX * this.startY -\n            this.endY * this.startX) /\n            Math.sqrt(Math.pow(this.endY - this.startY, 2) +\n                Math.pow(this.endX - this.startX, 2));\n        return distToLine < threshold;\n    };\n    return Line;\n}(Shape));\n// 화살표 클래스\nvar Arrow = /** @class */ (function (_super) {\n    __extends(Arrow, _super);\n    function Arrow() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.arrowSize = 10;\n        return _this;\n    }\n    Arrow.prototype.draw = function () {\n        _super.prototype.draw.call(this);\n        var angle = Math.atan2(this.endY - this.startY, this.endX - this.startX);\n        this.ctx.save();\n        this.ctx.translate(this.endX, this.endY);\n        this.ctx.rotate(angle);\n        this.ctx.beginPath();\n        this.ctx.moveTo(0, 0);\n        this.ctx.lineTo(-this.arrowSize, -this.arrowSize / 2);\n        this.ctx.lineTo(-this.arrowSize, this.arrowSize / 2);\n        this.ctx.closePath();\n        this.ctx.fillStyle = this.lineColor;\n        this.ctx.fill();\n        this.ctx.restore();\n    };\n    return Arrow;\n}(Line));\n// 원 클래스\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    function Circle(ctx, centerX, centerY, radius, lineColor, fillColor, lineWidth, lineStyle) {\n        var _this = _super.call(this, ctx, lineColor, fillColor, lineWidth, lineStyle) || this;\n        _this.centerX = centerX;\n        _this.centerY = centerY;\n        _this.radius = radius;\n        return _this;\n    }\n    Circle.prototype.draw = function () {\n        this.ctx.beginPath();\n        this.ctx.arc(this.centerX, this.centerY, this.radius, 0, 2 * Math.PI);\n        this.ctx.fillStyle = this.fillColor;\n        this.ctx.fill();\n        this.ctx.strokeStyle = this.lineColor;\n        this.ctx.lineWidth = this.lineWidth;\n        if (this.lineStyle === LineStyle.Dashed) {\n            this.ctx.setLineDash([5, 5]);\n        }\n        else {\n            this.ctx.setLineDash([]);\n        }\n        this.ctx.stroke();\n    };\n    Circle.prototype.isPointInside = function (x, y) {\n        var distance = Math.sqrt(Math.pow(x - this.centerX, 2) + Math.pow(y - this.centerY, 2));\n        return distance <= this.radius;\n    };\n    return Circle;\n}(Shape));\n// 사각형 클래스\nvar Rectangle = /** @class */ (function (_super) {\n    __extends(Rectangle, _super);\n    function Rectangle(ctx, x, y, width, height, lineColor, fillColor, lineWidth, lineStyle) {\n        var _this = _super.call(this, ctx, lineColor, fillColor, lineWidth, lineStyle) || this;\n        _this.x = x;\n        _this.y = y;\n        _this.width = width;\n        _this.height = height;\n        return _this;\n    }\n    Rectangle.prototype.draw = function () {\n        this.ctx.beginPath();\n        this.ctx.rect(this.x, this.y, this.width, this.height);\n        this.ctx.fillStyle = this.fillColor;\n        this.ctx.fill();\n        this.ctx.strokeStyle = this.lineColor;\n        this.ctx.lineWidth = this.lineWidth;\n        if (this.lineStyle === LineStyle.Dashed) {\n            this.ctx.setLineDash([5, 5]);\n        }\n        else {\n            this.ctx.setLineDash([]);\n        }\n        this.ctx.stroke();\n    };\n    Rectangle.prototype.isPointInside = function (x, y) {\n        return (x >= this.x &&\n            x <= this.x + this.width &&\n            y >= this.y &&\n            y <= this.y + this.height);\n    };\n    return Rectangle;\n}(Shape));\n// 삼각형 클래스\nvar Triangle = /** @class */ (function (_super) {\n    __extends(Triangle, _super);\n    function Triangle(ctx, x1, y1, x2, y2, x3, y3, lineColor, fillColor, lineWidth, lineStyle) {\n        var _this = _super.call(this, ctx, lineColor, fillColor, lineWidth, lineStyle) || this;\n        _this.x1 = x1;\n        _this.y1 = y1;\n        _this.x2 = x2;\n        _this.y2 = y2;\n        _this.x3 = x3;\n        _this.y3 = y3;\n        return _this;\n    }\n    Triangle.prototype.draw = function () {\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.x1, this.y1);\n        this.ctx.lineTo(this.x2, this.y2);\n        this.ctx.lineTo(this.x3, this.y3);\n        this.ctx.closePath();\n        this.ctx.fillStyle = this.fillColor;\n        this.ctx.fill();\n        this.ctx.strokeStyle = this.lineColor;\n        this.ctx.lineWidth = this.lineWidth;\n        if (this.lineStyle === LineStyle.Dashed) {\n            this.ctx.setLineDash([5, 5]);\n        }\n        else {\n            this.ctx.setLineDash([]);\n        }\n        this.ctx.stroke();\n    };\n    Triangle.prototype.isPointInside = function (x, y) {\n        // 삼각형 내부 판정을 위한 알고리즘 구현\n        // (이 부분은 복잡할 수 있으므로, 여기서는 간단한 근사치 구현만 제시합니다)\n        var dX = x - this.x3;\n        var dY = y - this.y3;\n        var dX21 = this.x3 - this.x2;\n        var dY12 = this.y1 - this.y2;\n        var D = dY12 * (this.x1 - this.x3) + dX21 * (this.y1 - this.y3);\n        var s = dY12 * dX + dX21 * dY;\n        var t = (this.y3 - this.y1) * dX + (this.x1 - this.x3) * dY;\n        if (D < 0)\n            return s <= 0 && t <= 0 && s + t >= D;\n        return s >= 0 && t >= 0 && s + t <= D;\n    };\n    return Triangle;\n}(Shape));\n// 자유 곡선 클래스\nvar Freehand = /** @class */ (function (_super) {\n    __extends(Freehand, _super);\n    function Freehand() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.points = [];\n        return _this;\n    }\n    Freehand.prototype.addPoint = function (x, y) {\n        this.points.push({ x: x, y: y });\n    };\n    Freehand.prototype.draw = function () {\n        if (this.points.length < 2)\n            return;\n        this.ctx.beginPath();\n        this.ctx.moveTo(this.points[0].x, this.points[0].y);\n        for (var i = 1; i < this.points.length; i++) {\n            this.ctx.lineTo(this.points[i].x, this.points[i].y);\n        }\n        this.ctx.strokeStyle = this.lineColor;\n        this.ctx.lineWidth = this.lineWidth;\n        if (this.lineStyle === LineStyle.Dashed) {\n            this.ctx.setLineDash([5, 5]);\n        }\n        else {\n            this.ctx.setLineDash([]);\n        }\n        this.ctx.stroke();\n    };\n    Freehand.prototype.isPointInside = function (x, y) {\n        // 자유 곡선의 경우 정확한 판정이 어려우므로, 근사치로 판단\n        var threshold = 5; // 픽셀 단위의 임계값\n        for (var _i = 0, _a = this.points; _i < _a.length; _i++) {\n            var point = _a[_i];\n            if (Math.abs(x - point.x) < threshold &&\n                Math.abs(y - point.y) < threshold) {\n                return true;\n            }\n        }\n        return false;\n    };\n    return Freehand;\n}(Shape));\n// DrawingState 클래스\nvar DrawingState = /** @class */ (function () {\n    function DrawingState() {\n        this.currentShape = ShapeType.Line;\n        this.lineColor = \"#000000\";\n        this.fillColor = \"#ffffff\";\n        this.lineWidth = 1;\n        this.lineStyle = LineStyle.Solid;\n    }\n    return DrawingState;\n}());\n// 확장된 HistoryManager 클래스\nvar HistoryManager = /** @class */ (function () {\n    function HistoryManager() {\n        this.undoStack = [];\n        this.redoStack = [];\n    }\n    HistoryManager.prototype.addAction = function (action) {\n        this.undoStack.push(action);\n        this.redoStack = []; // 새 동작이 추가되면 redo 스택을 초기화\n    };\n    HistoryManager.prototype.undo = function () {\n        if (this.undoStack.length > 0) {\n            var action = this.undoStack.pop();\n            this.redoStack.push(this.reverseAction(action));\n            return action;\n        }\n        return null;\n    };\n    HistoryManager.prototype.redo = function () {\n        if (this.redoStack.length > 0) {\n            var action = this.redoStack.pop();\n            this.undoStack.push(this.reverseAction(action));\n            return action;\n        }\n        return null;\n    };\n    HistoryManager.prototype.reverseAction = function (action) {\n        return {\n            type: action.type === \"add\" ? \"delete\" : \"add\",\n            shapes: __spreadArray([], action.shapes, true),\n        };\n    };\n    return HistoryManager;\n}());\n// Canvas 클래스 업데이트\nvar Canvas = /** @class */ (function () {\n    function Canvas(canvasId) {\n        this.shapes = [];\n        this.isDrawing = false;\n        this.startX = 0;\n        this.startY = 0;\n        this.currentFreehand = null;\n        this.isErasing = false;\n        this.canvas = document.getElementById(canvasId);\n        this.ctx = this.canvas.getContext(\"2d\");\n        this.drawingState = new DrawingState();\n        this.historyManager = new HistoryManager();\n        this.canvas.addEventListener(\"mousedown\", this.handleMouseDown.bind(this));\n        this.canvas.addEventListener(\"mousemove\", this.handleMouseMove.bind(this));\n        this.canvas.addEventListener(\"mouseup\", this.handleMouseUp.bind(this));\n    }\n    Canvas.prototype.handleMouseDown = function (event) {\n        this.isDrawing = true;\n        this.startX = event.clientX - this.canvas.offsetLeft;\n        this.startY = event.clientY - this.canvas.offsetTop;\n        if (this.drawingState.currentShape === ShapeType.Freehand) {\n            this.currentFreehand = new Freehand(this.ctx, this.drawingState.lineColor, \"\", this.drawingState.lineWidth, this.drawingState.lineStyle);\n            this.currentFreehand.addPoint(this.startX, this.startY);\n        }\n        if (this.isErasing) {\n            this.erase(this.startX, this.startY);\n        }\n    };\n    Canvas.prototype.handleMouseMove = function (event) {\n        if (!this.isDrawing)\n            return;\n        var endX = event.clientX - this.canvas.offsetLeft;\n        var endY = event.clientY - this.canvas.offsetTop;\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.redrawShapes();\n        if (this.isErasing) {\n            this.erase(endX, endY);\n        }\n        else if (this.drawingState.currentShape === ShapeType.Freehand &&\n            this.currentFreehand) {\n            this.currentFreehand.addPoint(endX, endY);\n            this.currentFreehand.draw();\n        }\n        else {\n            this.drawCurrentShape(endX, endY);\n        }\n    };\n    Canvas.prototype.handleMouseUp = function (event) {\n        if (!this.isDrawing)\n            return;\n        var endX = event.clientX - this.canvas.offsetLeft;\n        var endY = event.clientY - this.canvas.offsetTop;\n        if (this.isErasing) {\n            var erasedShapes = this.eraseShapes(endX, endY);\n            if (erasedShapes.length > 0) {\n                this.historyManager.addAction({ type: \"delete\", shapes: erasedShapes });\n            }\n        }\n        else {\n            var shape = void 0;\n            switch (this.drawingState.currentShape) {\n                case ShapeType.Line:\n                    shape = new Line(this.ctx, this.startX, this.startY, endX, endY, this.drawingState.lineColor, this.drawingState.lineWidth, this.drawingState.lineStyle);\n                    break;\n                case ShapeType.Arrow:\n                    shape = new Arrow(this.ctx, this.startX, this.startY, endX, endY, this.drawingState.lineColor, this.drawingState.lineWidth, this.drawingState.lineStyle);\n                    break;\n                case ShapeType.Circle:\n                    var radius = Math.sqrt(Math.pow(endX - this.startX, 2) + Math.pow(endY - this.startY, 2));\n                    shape = new Circle(this.ctx, this.startX, this.startY, radius, this.drawingState.lineColor, this.drawingState.fillColor, this.drawingState.lineWidth, this.drawingState.lineStyle);\n                    break;\n                case ShapeType.Rectangle:\n                    shape = new Rectangle(this.ctx, this.startX, this.startY, endX - this.startX, endY - this.startY, this.drawingState.lineColor, this.drawingState.fillColor, this.drawingState.lineWidth, this.drawingState.lineStyle);\n                    break;\n                case ShapeType.Triangle:\n                    var centerX = (this.startX + endX) / 2;\n                    shape = new Triangle(this.ctx, this.startX, endY, centerX, this.startY, endX, endY, this.drawingState.lineColor, this.drawingState.fillColor, this.drawingState.lineWidth, this.drawingState.lineStyle);\n                    break;\n                case ShapeType.Freehand:\n                    if (this.currentFreehand) {\n                        shape = this.currentFreehand;\n                    }\n                    else {\n                        throw new Error(\"Freehand shape not initialized\");\n                    }\n                    break;\n                default:\n                    throw new Error(\"Unsupported shape type\");\n            }\n            this.shapes.push(shape);\n            this.historyManager.addAction({ type: \"add\", shapes: [shape] });\n        }\n        this.redrawShapes();\n        this.isDrawing = false;\n        this.currentFreehand = null;\n    };\n    Canvas.prototype.eraseShapes = function (x, y) {\n        var erasedShapes = [];\n        for (var i = this.shapes.length - 1; i >= 0; i--) {\n            if (this.shapes[i].isPointInside(x, y)) {\n                erasedShapes.push.apply(erasedShapes, this.shapes.splice(i, 1));\n            }\n        }\n        return erasedShapes;\n    };\n    Canvas.prototype.drawCurrentShape = function (endX, endY) {\n        switch (this.drawingState.currentShape) {\n            case ShapeType.Line:\n                this.ctx.beginPath();\n                this.ctx.moveTo(this.startX, this.startY);\n                this.ctx.lineTo(endX, endY);\n                this.ctx.stroke();\n                break;\n            case ShapeType.Arrow:\n                var arrow = new Arrow(this.ctx, this.startX, this.startY, endX, endY, this.drawingState.lineColor, this.drawingState.lineWidth, this.drawingState.lineStyle);\n                arrow.draw();\n                break;\n            case ShapeType.Circle:\n                var radius = Math.sqrt(Math.pow(endX - this.startX, 2) + Math.pow(endY - this.startY, 2));\n                var circle = new Circle(this.ctx, this.startX, this.startY, radius, this.drawingState.lineColor, this.drawingState.fillColor, this.drawingState.lineWidth, this.drawingState.lineStyle);\n                circle.draw();\n                break;\n            case ShapeType.Rectangle:\n                var rect = new Rectangle(this.ctx, this.startX, this.startY, endX - this.startX, endY - this.startY, this.drawingState.lineColor, this.drawingState.fillColor, this.drawingState.lineWidth, this.drawingState.lineStyle);\n                rect.draw();\n                break;\n            case ShapeType.Triangle:\n                var centerX = (this.startX + endX) / 2;\n                var triangle = new Triangle(this.ctx, this.startX, endY, centerX, this.startY, endX, endY, this.drawingState.lineColor, this.drawingState.fillColor, this.drawingState.lineWidth, this.drawingState.lineStyle);\n                triangle.draw();\n                break;\n        }\n    };\n    Canvas.prototype.erase = function (x, y) {\n        for (var i = this.shapes.length - 1; i >= 0; i--) {\n            if (this.shapes[i].isPointInside(x, y)) {\n                this.shapes.splice(i, 1);\n                break;\n            }\n        }\n        this.redrawShapes();\n    };\n    Canvas.prototype.setEraseMode = function (isErasing) {\n        this.isErasing = isErasing;\n    };\n    Canvas.prototype.redrawShapes = function () {\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        for (var _i = 0, _a = this.shapes; _i < _a.length; _i++) {\n            var shape = _a[_i];\n            shape.draw();\n        }\n    };\n    Canvas.prototype.undo = function () {\n        var action = this.historyManager.undo();\n        if (action) {\n            this.applyAction(action);\n            this.redrawShapes();\n        }\n    };\n    Canvas.prototype.redo = function () {\n        var action = this.historyManager.redo();\n        if (action) {\n            this.applyAction(action);\n            this.redrawShapes();\n        }\n    };\n    Canvas.prototype.applyAction = function (action) {\n        var _a;\n        if (action.type === \"add\") {\n            (_a = this.shapes).push.apply(_a, action.shapes);\n        }\n        else {\n            var _loop_1 = function (shape) {\n                var index = this_1.shapes.findIndex(function (s) { return s === shape; });\n                if (index !== -1) {\n                    this_1.shapes.splice(index, 1);\n                }\n            };\n            var this_1 = this;\n            for (var _i = 0, _b = action.shapes; _i < _b.length; _i++) {\n                var shape = _b[_i];\n                _loop_1(shape);\n            }\n        }\n    };\n    Canvas.prototype.setCurrentShape = function (shape) {\n        this.drawingState.currentShape = shape;\n    };\n    Canvas.prototype.setLineColor = function (color) {\n        this.drawingState.lineColor = color;\n    };\n    Canvas.prototype.setFillColor = function (color) {\n        this.drawingState.fillColor = color;\n    };\n    Canvas.prototype.setLineWidth = function (width) {\n        this.drawingState.lineWidth = width;\n    };\n    Canvas.prototype.setLineStyle = function (style) {\n        this.drawingState.lineStyle = style;\n    };\n    return Canvas;\n}());\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    var canvas = new Canvas(\"drawingCanvas\");\n    var buttons = {\n        line: document.getElementById(\"lineBtn\"),\n        arrow: document.getElementById(\"arrowBtn\"),\n        circle: document.getElementById(\"circleBtn\"),\n        rectangle: document.getElementById(\"rectangleBtn\"),\n        triangle: document.getElementById(\"triangleBtn\"),\n        freehand: document.getElementById(\"freehandBtn\"),\n        erase: document.getElementById(\"eraseBtn\"),\n        undo: document.getElementById(\"undoBtn\"),\n        redo: document.getElementById(\"redoBtn\"),\n    };\n    (_a = buttons.line) === null || _a === void 0 ? void 0 : _a.addEventListener(\"click\", function () {\n        return canvas.setCurrentShape(ShapeType.Line);\n    });\n    (_b = buttons.arrow) === null || _b === void 0 ? void 0 : _b.addEventListener(\"click\", function () {\n        return canvas.setCurrentShape(ShapeType.Arrow);\n    });\n    (_c = buttons.circle) === null || _c === void 0 ? void 0 : _c.addEventListener(\"click\", function () {\n        return canvas.setCurrentShape(ShapeType.Circle);\n    });\n    (_d = buttons.rectangle) === null || _d === void 0 ? void 0 : _d.addEventListener(\"click\", function () {\n        return canvas.setCurrentShape(ShapeType.Rectangle);\n    });\n    (_e = buttons.triangle) === null || _e === void 0 ? void 0 : _e.addEventListener(\"click\", function () {\n        return canvas.setCurrentShape(ShapeType.Triangle);\n    });\n    (_f = buttons.freehand) === null || _f === void 0 ? void 0 : _f.addEventListener(\"click\", function () {\n        return canvas.setCurrentShape(ShapeType.Freehand);\n    });\n    (_g = buttons.erase) === null || _g === void 0 ? void 0 : _g.addEventListener(\"click\", function () { return canvas.setEraseMode(true); });\n    (_h = buttons.undo) === null || _h === void 0 ? void 0 : _h.addEventListener(\"click\", function () { return canvas.undo(); });\n    (_j = buttons.redo) === null || _j === void 0 ? void 0 : _j.addEventListener(\"click\", function () { return canvas.redo(); });\n    // 디버깅을 위한 콘솔 로그\n    console.log(\"Event listeners set up\");\n});\n\n\n//# sourceURL=webpack://canvas-drawing-app/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.ts"]();
/******/ 	
/******/ })()
;